/*
 *  RapidMiner
 *
 *  Copyright (C) 2001-2007 by Rapid-I and the contributors
 *
 *  Complete list of developers available at our web site:
 *
 *       http://rapid-i.com
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License as 
 *  published by the Free Software Foundation; either version 2 of the
 *  License, or (at your option) any later version. 
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *  General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 *  USA.
 */
package com.rapidminer.operator.meta;

import java.util.Iterator;
import java.util.List;

import com.rapidminer.operator.IOContainer;
import com.rapidminer.operator.IOObject;
import com.rapidminer.operator.Operator;
import com.rapidminer.operator.OperatorDescription;
import com.rapidminer.operator.OperatorException;
import com.rapidminer.operator.UserError;
import com.rapidminer.operator.performance.PerformanceVector;
import com.rapidminer.parameter.ParameterType;
import com.rapidminer.tools.Tools;


/**
 * <p>This operator finds the optimal values for a set of parameters using a grid
 * search. The parameter <var>parameters</var> is a list of key value pairs
 * where the keys are of the form <code>operator_name.parameter_name</code> and
 * the value is either a comma separated list of values (e.g. 10,15,20,25) or an 
 * interval definition in the format [start;end;step] (e.g. [10;25;5]). </p> 
 * 
 * <p>The operator returns an
 * optimal {@link ParameterSet} which can as well be written to a file with a
 * {@link com.rapidminer.operator.io.ParameterSetWriter}. This parameter set
 * can be read in another process using a
 * {@link com.rapidminer.operator.io.ParameterSetLoader}.</p> 
 * 
 * <p>The file format of the parameter set file is straightforward and can easily be
 * generated by external applications. Each line is of the form
 * <center><code>operator_name.parameter_name = value</code></center>
 * </p>
 *   
 * <p>Please refer to section
 * {@rapidminer.ref sec:parameter_optimization|Advanced Processes/Parameter and performance analysis}
 * for an example application. Another parameter optimization schems like the 
 * {@link EvolutionaryParameterOptimizationOperator} might also be useful if the best ranges
 * and dependencies are not known at all. Another operator which works similar to this parameter 
 * optimization operator is the operator {@link ParameterIteration}. In contrast to the optimization
 * operator, this operator simply iterates through all parameter combinations. This might be 
 * especially useful for plotting purposes.
 * </p>
 * 
 * @author Simon Fischer, Helge Homburg, Ingo Mierswa
 * @version $Id: GridSearchParameterOptimizationOperator.java,v 1.9 2006/03/21
 *          15:35:49 ingomierswa Exp $
 */
public class GridSearchParameterOptimizationOperator extends ParameterOptimizationOperator {
    
    protected List parameterList;

    protected Operator[] operators;

    protected String[] parameters;

    protected String[][] values;

    protected int[] currentIndex;

    protected int numberOfCombinations = 1;
    
	private ParameterSet best;

	public GridSearchParameterOptimizationOperator(OperatorDescription description) {
		super(description);
	}

    public void getParametersToOptimize() throws OperatorException {
        parameterList = getParameterList(PARAMETER_PARAMETERS); 
        operators = new Operator[parameterList.size()];
        parameters = new String[parameterList.size()];
        values = new String[parameterList.size()][];
        currentIndex = new int[parameterList.size()];
        int index = 0;
        this.numberOfCombinations = 1;
        Iterator iter = parameterList.iterator();
        while (iter.hasNext()) {
            Object[] keyValue = (Object[]) iter.next();
            String[] parameter = ((String) keyValue[0]).split("\\.");
            if (parameter.length != 2)
                throw new UserError(this, 907, keyValue[0]);
            Operator operator = getProcess().getOperator(parameter[0]);
            if (operator == null)
                throw new UserError(this, 109, parameter[0]);
            operators[index] = operator;
            parameters[index] = parameter[1];
            ParameterType targetType = operators[index].getParameters().getParameterType(parameters[index]);
            if (targetType == null) {
                throw new UserError(this, 906, parameter[0] + "." + parameter[1]);
            }
            String paraString = (String)keyValue[1];
            int startIndex = paraString.indexOf("["); 
            if (startIndex >= 0) {
                try {
                    int endIndex = paraString.indexOf("]");
                    if (endIndex > startIndex) {
                        String[] startEndStepArray = paraString.substring(startIndex + 1, endIndex).trim().split(";");
                        if (startEndStepArray.length != 3)
                            throw new Exception("number of entries must be 3 (start, end, and step size)");
                        double startValue = Double.parseDouble(startEndStepArray[0]);
                        double endValue   = Double.parseDouble(startEndStepArray[1]);
                        double step       = Double.parseDouble(startEndStepArray[2]);
                        if (step == 0) {
                            throw new Exception("step size of 0 is not allowed");                            
                        }
                        if (endValue <= startValue + step) {
                            throw new Exception("end value must at least be as large as start value plus step size");
                        }
                        String[] allValues = new String[(int)((endValue - startValue) / step) + 1];
                        double currentValue = startValue;
                        int counter = 0;
                        while (currentValue <= endValue) {
                            allValues[counter] = Tools.formatIntegerIfPossible(currentValue, 16);
                            currentValue += step;
                            counter++;
                        }
                        values[index] = allValues;
                    } else {
                        throw new Exception("']' was missing");
                    }
                } catch (Throwable e) {
                    throw new UserError(this, 116, keyValue[0], "Parameter values must be defined as a comma separated list or by [start;end;step], was '" + keyValue[1] + "'. Error: " + e.getMessage());
                }
            } else {
                values[index] = ((String) keyValue[1]).split(",");
            }
            numberOfCombinations *= values[index].length;
            index++;
        }
    }
    
	public double getCurrentBestPerformance() {
	    if (best != null) {
	        return best.getPerformance().getMainCriterion().getAverage();
        } else {
	        return Double.NaN;
        }
    }
    
	public IOObject[] apply() throws OperatorException {
		IOContainer input = getInput();

        getParametersToOptimize();

        // start optimization
        log("Total number of combinations is " + numberOfCombinations);
        
        if (numberOfCombinations <= 1)
            throw new UserError(this, 922);
        
        int counter = 1;
		best = null;
		while (true) {
			log("Using parameter set " + counter + " / " + numberOfCombinations + ":");
			// set all parameter values
			for (int j = 0; j < operators.length; j++) {
				operators[j].getParameters().setParameter(parameters[j], values[j][currentIndex[j]]);
				log(operators[j] + "." + parameters[j] + " = " + values[j][currentIndex[j]]);
			}

			setInput(input.copy());
			PerformanceVector performance = getPerformance();
			if ((best == null) || ((performance != null) && (performance.compareTo(best.getPerformance()) > 0))) {
				String[] bestValues = new String[parameters.length];
				for (int j = 0; j < parameters.length; j++) {
				    bestValues[j] = values[j][currentIndex[j]];
				}
				best = new ParameterSet(operators, parameters, bestValues, performance);
			}

			// next parameter values
			int k = 0;
			boolean ok = true;
			while (!(++currentIndex[k] < values[k].length)) {
				currentIndex[k] = 0;
				k++;
				if (k >= currentIndex.length) {
					ok = false;
					break;
				}
			}
			if (!ok)
				break;

			inApplyLoop();
            counter++;
		}

		return new IOObject[] { best, best.getPerformance() };
	}
}
