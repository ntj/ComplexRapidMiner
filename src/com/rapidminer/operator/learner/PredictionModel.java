/*
 *  RapidMiner
 *
 *  Copyright (C) 2001-2007 by Rapid-I and the contributors
 *
 *  Complete list of developers available at our web site:
 *
 *       http://rapid-i.com
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License as 
 *  published by the Free Software Foundation; either version 2 of the
 *  License, or (at your option) any later version. 
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *  General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 *  USA.
 */
package com.rapidminer.operator.learner;

import java.util.Iterator;

import com.rapidminer.example.Attribute;
import com.rapidminer.example.Attributes;
import com.rapidminer.example.ExampleSet;
import com.rapidminer.example.set.HeaderExampleSet;
import com.rapidminer.example.set.RemappedExampleSet;
import com.rapidminer.example.table.AttributeFactory;
import com.rapidminer.example.table.ExampleTable;
import com.rapidminer.operator.AbstractModel;
import com.rapidminer.operator.OperatorException;
import com.rapidminer.tools.Ontology;


/**
 * PredictionModel is the superclass for all objects generated by learners, i.e.
 * it can be used to create a prediction for a given example set.
 * 
 * @author Ingo Mierswa
 * @version $Id: PredictionModel.java,v 1.2 2007/07/13 22:52:12 ingomierswa Exp $
 */
public abstract class PredictionModel extends AbstractModel {
    
    /** Created a new prediction model which was built on the given example set. Please note
     *  that the given example set is automatically transformed into a {@link HeaderExampleSet}
     *  which means that no reference to the data itself is kept but only to the header, i.e.
     *  to the attribute meta descriptions. */
    protected PredictionModel(ExampleSet trainingExampleSet) {
        super(trainingExampleSet);
    }
    
	/**
	 * Subclasses should iterated through the given example set and set the
	 * prediction for each example. The given predicted label attribute was
	 * already be added to the example set and should be used to set the
	 * predicted values.
	 */
	public abstract void performPrediction(ExampleSet exampleSet, Attribute predictedLabel) throws OperatorException;

	/**
	 * Applies the model by creating a predicted label attribue and setting the
	 * predicted label values.
	 */
	public void apply(ExampleSet exampleSet) throws OperatorException {
        RemappedExampleSet mappedExampleSet = new RemappedExampleSet(exampleSet, getTrainingHeader());
		Attribute predictedLabel = createPredictedLabel(mappedExampleSet);
		performPrediction(mappedExampleSet, predictedLabel);
	}

	/** Returns the label attribute. */
	public Attribute getLabel() {
		return getTrainingHeader().getAttributes().getLabel();
	}
    
	/**
	 * Creates a predicted label for the given example set based on the label
	 * attribute defined for this prediction model. Subclasses which override
	 * this method should first invoke super.createPredictedLabel(exampleSet)
	 * and should then replace the attribute with a new predicted label
	 * attribute via a method call like
	 * <code>exampleSet.replaceAttribute(predictedLabel, AttributeFactory.changeValueType(predictedLabel, Ontology.REAL)); </code>.
	 * This might be useful in cases where a crisp nominal prediction should be
	 * replaced by confidence predictions.
	 */
	protected Attribute createPredictedLabel(ExampleSet exampleSet) {
		Attribute label = getLabel();
		// create and add prediction attribute
		Attribute predictedLabel = AttributeFactory.createAttribute(label, Attributes.PREDICTION_NAME);
		ExampleTable table = exampleSet.getExampleTable();
		table.addAttribute(predictedLabel);
		exampleSet.getAttributes().setPredictedLabel(predictedLabel);

		// create and add confidence attributes for nominal labels
		if (label.isNominal()) {
			Iterator i = predictedLabel.getMapping().getValues().iterator();
			while (i.hasNext()) {
				String value = (String) i.next();
				Attribute confidence = AttributeFactory.createAttribute(Attributes.CONFIDENCE_NAME + "(" + value + ")", Ontology.REAL);
				table.addAttribute(confidence);
				exampleSet.getAttributes().setSpecialAttribute(confidence, Attributes.CONFIDENCE_NAME + "(" + value + ")");
			}
		}
		return predictedLabel;
	}

	public String toString() {
		return getName() + " (prediction model for label " + getTrainingHeader().getAttributes().getLabel() + ")";
	}

    /**
     * Helper method in order to lower memory consumption. This method should be
     * invoked after a predicted label and confidence are not longer needed,
     * e.g. after each crossvalidation run or after a meta learning iteration.
     */
    public static void removePredictedLabel(ExampleSet exampleSet) {
        removePredictedLabel(exampleSet, true, true);
    }
    
	/**
	 * Helper method in order to lower memory consumption. This method should be
	 * invoked after a predicted label and confidence are not longer needed,
	 * e.g. after each crossvalidation run or after a meta learning iteration.
	 */
	public static void removePredictedLabel(ExampleSet exampleSet, boolean removePredictionFromTable, boolean removeConfidencesFromTable) {
		Attribute predictedLabel = exampleSet.getAttributes().getPredictedLabel();
		if (predictedLabel != null) { // remove old predicted label
			if (predictedLabel.isNominal()) {
				java.util.Iterator i = predictedLabel.getMapping().getValues().iterator();
				while (i.hasNext()) {
					String value = (String) i.next();
					Attribute currentConfidenceAttribute = exampleSet.getAttributes().getSpecial(Attributes.CONFIDENCE_NAME + "(" + value + ")");
					if (currentConfidenceAttribute != null) {
						exampleSet.getAttributes().remove(currentConfidenceAttribute);
                        if (removeConfidencesFromTable)
                            exampleSet.getExampleTable().removeAttribute(currentConfidenceAttribute);
					}
				}
			}
			exampleSet.getAttributes().remove(predictedLabel);
            if (removePredictionFromTable)
                exampleSet.getExampleTable().removeAttribute(predictedLabel);
		}
	}
    
    /** Copies the predicted label from the source example set to the destination example set. 
     *  Does nothing if the source does not contain a predicted label. */
    public static void copyPredictedLabel(ExampleSet source, ExampleSet destination) {
        Attribute predictedLabel = source.getAttributes().getPredictedLabel();
        if (predictedLabel != null) {
            removePredictedLabel(destination, true, true);
            if (predictedLabel.isNominal()) {
                java.util.Iterator i = predictedLabel.getMapping().getValues().iterator();
                while (i.hasNext()) {
                    String value = (String) i.next();
                    Attribute currentConfidenceAttribute = source.getAttributes().getSpecial(Attributes.CONFIDENCE_NAME + "(" + value + ")");
                    if (currentConfidenceAttribute != null) {
                        destination.getAttributes().setSpecialAttribute(currentConfidenceAttribute, Attributes.CONFIDENCE_NAME + "(" + value + ")");
                    }
                }
            }
            destination.getAttributes().setPredictedLabel(predictedLabel);
        }
    }
}
