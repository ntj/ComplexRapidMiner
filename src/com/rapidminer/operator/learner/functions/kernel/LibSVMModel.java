/*
 *  RapidMiner
 *
 *  Copyright (C) 2001-2007 by Rapid-I and the contributors
 *
 *  Complete list of developers available at our web site:
 *
 *       http://rapid-i.com
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License as 
 *  published by the Free Software Foundation; either version 2 of the
 *  License, or (at your option) any later version. 
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *  General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 *  USA.
 */
package com.rapidminer.operator.learner.functions.kernel;

import java.util.Iterator;

import com.rapidminer.example.Attribute;
import com.rapidminer.example.Example;
import com.rapidminer.example.ExampleSet;
import com.rapidminer.example.FastExample2SparseTransform;
import com.rapidminer.tools.Tools;

import libsvm.Svm;
import libsvm.svm_model;
import libsvm.svm_node;

/**
 * A model generated by the <a
 * href="http://www.csie.ntu.edu.tw/~cjlin/libsvm">libsvm</a> by Chih-Chung
 * Chang and Chih-Jen Lin.
 * 
 * @author Ingo Mierswa
 * @version $Id: LibSVMModel.java,v 1.6 2007/07/18 11:15:29 ingomierswa Exp $
 */
public class LibSVMModel extends KernelModel {

	private static final long serialVersionUID = -2654603017217487365L;

	private svm_model model;

    private int numberOfAttributes;

	public LibSVMModel(ExampleSet exampleSet, svm_model model, int numberOfAttributes) {
		super(exampleSet);
		this.model = model;
        this.numberOfAttributes = numberOfAttributes;
	}
    
    public boolean isClassificationModel() {
        return getLabel().isNominal();
    }
    
    public double getAlpha(int index) {
        return model.sv_coef[0][index];
    }
    
    public String getId(int index) {
        return null;
    }
    
    public int getNumberOfSupportVectors() {
        return model.SV.length;
    }
    
    public int getNumberOfAttributes() {
        return numberOfAttributes;
    }
    
	public double getBias() {
		return this.model.rho[0];
	}

	public SupportVector getSupportVector(int index) {
		svm_node[] nodes = this.model.SV[index];
		double[] x = new double[getNumberOfAttributes()];
		for (int i = 0; i < nodes.length; i++)
			x[nodes[i].index] = nodes[i].value;
		return new SupportVector(x, getRegressionLabel(index), Math.abs(getAlpha(index)));
	}
	
    public double getAttributeValue(int exampleIndex, int attributeIndex) {
        double[] dense = new double[numberOfAttributes];
        svm_node[] node = model.SV[exampleIndex];
        for (int i = 0; i < node.length; i++) {
            dense[node[i].index] = node[i].value;
        }
        return dense[attributeIndex];
    }
    
    public String getClassificationLabel(int index) {
    	double functionValue = getRegressionLabel(index);
    	if (!Double.isNaN(functionValue))
    		return getLabel().getMapping().mapIndex((int)functionValue);
    	else
    		return "?";
    }
    
    public double getRegressionLabel(int index) {
    	if (model.labelValues != null)
    		return model.labelValues[index];
    	else
    		return Double.NaN;
    }
    
    public double getFunctionValue(int index) {
        if (getLabel().isNominal()) {
            double[] classProbs = new double[getLabel().getMapping().size()];
            Svm.svm_predict_probability(model, model.SV[index], classProbs);
            return classProbs[0];
        } else {
            return Svm.svm_predict(model, model.SV[index]);
        }
    }
    
	public void performPrediction(ExampleSet exampleSet, Attribute predictedLabel) {
		FastExample2SparseTransform ripper = new FastExample2SparseTransform(exampleSet);
		Iterator<Example> i = exampleSet.iterator();
		while (i.hasNext()) {
			Example e = i.next();
			if (getLabel().isNominal()) {
				// set prediction
				svm_node[] currentNodes = LibSVMLearner.makeNodes(e, ripper);
				
				// set class probs (properly calculated during training)
				if ((model.probA != null) && (model.probB != null)) {					
					double[] classProbs = new double[model.nr_class];
					int nr_class = model.nr_class;
					double[] dec_values = new double[nr_class * (nr_class - 1) / 2];
					Svm.svm_predict_values(model, currentNodes, dec_values);

					double min_prob = 1e-7;
					double[][] pairwise_prob = new double[nr_class][nr_class];

					int k = 0;
					for (int a = 0; a < nr_class; a++)
						for (int j = a + 1; j < nr_class; j++) {
							pairwise_prob[a][j] = Math.min(Math.max(Svm.sigmoid_predict(dec_values[k], model.probA[k], model.probB[k]), min_prob), 1 - min_prob);
							pairwise_prob[j][a] = 1 - pairwise_prob[a][j];
							k++;
						}
					Svm.multiclass_probability(nr_class, pairwise_prob, classProbs);

					for (k = 0; k < nr_class; k++) {
						e.setConfidence(getLabel().getMapping().mapIndex(model.label[k]), classProbs[k]);
					}
					
					double predictedClass = Svm.svm_predict_probability(model, currentNodes, classProbs);
					e.setValue(predictedLabel, predictedClass);
				} else {
					double predictedClass = Svm.svm_predict(model, currentNodes);
					e.setValue(predictedLabel, predictedClass);
					// use simple calculation for binary cases...
					if (getLabel().getMapping().size() == 2) { 
						double[] functionValues = new double[model.nr_class];
						Svm.svm_predict_values(model, currentNodes, functionValues);
						double prediction = functionValues[0];
						e.setConfidence(getLabel().getMapping().mapIndex(model.label[0]), 1.0d / (1.0d + java.lang.Math.exp(-prediction)));
						e.setConfidence(getLabel().getMapping().mapIndex(model.label[1]), 1.0d / (1.0d + java.lang.Math.exp(prediction)));
					} else {
						// ...or no proper confidence value for the multi class setting
						e.setConfidence(getLabel().getMapping().mapIndex((int)predictedClass), 1.0d);
					}
				}
			} else {
				e.setValue(predictedLabel, Svm.svm_predict(model, LibSVMLearner.makeNodes(e, ripper))); 
			}
		}
	}
	
	public String toString() {
		StringBuffer result = new StringBuffer(super.toString() + Tools.getLineSeparator());
		result.append("number of classes: " + model.nr_class + Tools.getLineSeparator());
		if (getLabel().isNominal()) {
			for (int i = 0; i < model.nSV.length; i++) {
				result.append("number of support vectors for class " + getLabel().getMapping().mapIndex(model.label[i]) + ": " + model.nSV[i] + Tools.getLineSeparator());
			}
		} else {
			result.append("number of support vectors: " + model.l + Tools.getLineSeparator());
		}
		return result.toString();
	}
}
